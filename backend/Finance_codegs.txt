/**
 * JSON / JSONP v√°laszgener√°l√°s (Booklist minta alapj√°n).
 */
function createJsonOrJsonpResponse_(obj, callback) {
  const json = JSON.stringify(obj);
  if (callback) {
    return ContentService
      .createTextOutput(callback + "(" + json + ");")
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService
    .createTextOutput(json)
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * GET alap√∫ API (JSONP t√°mogat√°ssal).
 * Ezt fogja h√≠vni a file://-r≈ël fut√≥ HTML.
 */
function doGet(e) {
  const p = e && e.parameter ? e.parameter : {};
  const action = p.action;
  const callback = p.callback;
  let result;

  try {

    if (action === "addTransaction") {
      const tx = {
        month:            p.month            || "",
        date:             p.date             || "",
        amount:           p.amount           || "",
        title:            p.title            || "",
        category:         p.category         || "",
        payment_type:     p.payment_type     || "",
        transaction_type: p.transaction_type || "",
        is_shared:        p.is_shared        || "",
        statement_item:   p.statement_item   || "",
        paid_by:          p.paid_by          || ""
      };
      result = addTransaction_(tx);

    } else if (action === "getTransactions") {
      result = getTransactions_();

    } else if (action === "getValueSets") {
      result = getValueSets_();

    } else if (action === "updateTransaction") {
      const tx = {
        id:               p.id               || "",
        month:            p.month            || "",
        date:             p.date             || "",
        amount:           p.amount           || "",
        title:            p.title            || "",
        category:         p.category         || "",
        payment_type:     p.payment_type     || "",
        transaction_type: p.transaction_type || "",
        is_shared:        p.is_shared        || "",
        statement_item:   p.statement_item   || "",
        paid_by:          p.paid_by          || ""
      };
      result = updateTransaction_(tx);

    } else if (action === "addValueToSet") {
      result = addValueToSet_(p);

    } else if (action === "getSharedExpenses") {
      result = getSharedExpenses_(p);
    } else if (action === "updateSharedExpense") {
      result = updateSharedExpense_(p.id, p.field, p.value);

    } else {
      result = { success: false, error: "Ismeretlen action: " + action };
    }

  } catch (err) {
    result = { success: false, error: err.message || String(err) };
  }

  // üî• A HELYES HELYEN h√≠vjuk meg a JSONP-t
  return createJsonOrJsonpResponse_(result, callback);
}



/**
 * Seg√©df√ºggv√©ny: besz√∫r egy sort a Transactions sheetbe.
 */
function addTransaction_(tx) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Transactions");
  if (!sheet) {
    throw new Error('Nem tal√°lhat√≥ a "Transactions" nev≈± munkalap.');
  }

  const id = Utilities.getUuid();
  const created_at = new Date();
  const created_by = Session.getActiveUser().getEmail() || "unknown";

  const row = [
    id,
    tx.month,
    formatDateForStore_(tx.date),
    tx.amount,
    tx.title,
    tx.category,
    tx.payment_type,
    tx.transaction_type,
    tx.is_shared,
    tx.statement_item,
    created_by,
    created_at
  ];

  sheet.appendRow(row);
  addValueIfMissing_("title_values", tx.title);
  addValueIfMissing_("category_values", tx.category);
  addValueIfMissing_("payment_type_values", tx.payment_type);
  addValueIfMissing_("transaction_type_values", tx.transaction_type);
    // --- √öJ: megosztott k√∂lts√©g automatikus szinkron ---
    syncSharedExpenseForTransaction_({
      id:           id,
      month:        tx.month,
      date:         tx.date,
      amount:       tx.amount,
      title:        tx.title,
      is_shared:    tx.is_shared,
      paid_by:      tx.paid_by
    });
  return { success: true, id: id };
}
/**
 * Seg√©df√ºggv√©ny: m√≥dos√≠t egy megl√©v≈ë sort a Transactions sheetben.
 */
function updateTransaction_(tx) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Transactions");
  if (!sheet) {
    throw new Error('Nem tal√°lhat√≥ a "Transactions" nev≈± munkalap.');
  }

  const data = sheet.getDataRange().getValues();
  const header = data[0];

  // ID az els≈ë oszlopban van ‚Üí index 0
  const idCol = 0;

  // Megkeress√ºk, melyik sorban van az ID
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idCol]).trim() === String(tx.id).trim()) {
      rowIndex = i + 1; // Google Sheets 1-indexelt
      break;
    }
  }

  if (rowIndex === -1) {
    return { success: false, error: "Nincs ilyen ID: " + tx.id };
  }

  // Fel√ºl√≠rjuk a sort (ID oszlopot nem m√≥dos√≠tjuk)
  const updatedRow = [
    tx.id,
    tx.month,
    formatDateForStore_(tx.date),
    tx.amount,
    tx.title,
    tx.category,
    tx.payment_type,
    tx.transaction_type,
    tx.is_shared,
    tx.statement_item,
    data[rowIndex - 1][10], // created_by (v√°ltozatlan)
    data[rowIndex - 1][11]  // created_at (v√°ltozatlan)
  ];

  sheet.getRange(rowIndex, 1, 1, updatedRow.length).setValues([updatedRow]);
    // --- √öJ: megosztott k√∂lts√©g automatikus szinkron ---
    syncSharedExpenseForTransaction_({
      id:           tx.id,
      month:        tx.month,
      date:         tx.date,
      amount:       tx.amount,
      title:        tx.title,
      is_shared:    tx.is_shared,
      paid_by:      tx.paid_by
    });
  return { success: true, id: tx.id };
}

function getTransactions_() {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Transactions");
  const data = sheet.getDataRange().getValues();

  const header = data[0];
  const rows = data.slice(1).map(row => {
    const obj = {};
    header.forEach((h, i) => {
      obj[h] = row[i];
    });
    return obj;
  });

  return { success: true, data: rows };
}
function getValueSets_() {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Value_Sets");
  if (!sheet) {
    return { success: false, error: 'Nem tal√°lhat√≥ a "Value_Sets" munkalap.' };
  }

  const values = sheet.getDataRange().getValues();
  if (values.length < 2) {
    return {
      success: true,
      sets: {
        titles: [],
        categories: [],
        payments: [],
        types: [],
        paid_by: []
      }
    };
  }

  const header = values[0];

  // Oszlopindexek
  const colTitle    = header.indexOf("title_values");
  const colCategory = header.indexOf("category_values");
  const colPayment  = header.indexOf("payment_type_values");
  const colType     = header.indexOf("transaction_type_values");
  const colPaidBy   = header.indexOf("paid_by");

  const titles     = [];
  const categories = [];
  const payments   = [];
  const types      = [];
  const paid_by    = [];

  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    if (colTitle    !== -1 && row[colTitle])    titles.push(row[colTitle]);
    if (colCategory !== -1 && row[colCategory]) categories.push(row[colCategory]);
    if (colPayment  !== -1 && row[colPayment])  payments.push(row[colPayment]);
    if (colType     !== -1 && row[colType])     types.push(row[colType]);
    if (colPaidBy   !== -1 && row[colPaidBy])   paid_by.push(row[colPaidBy]);
  }

  return {
    success: true,
    sets: {
      titles,
      categories,
      payments,
      types,
      paid_by
    }
  };
}

function addValueIfMissing_(columnName, value) {
  if (!value) return;

  const sheet = SpreadsheetApp.getActive().getSheetByName("Value_Sets");
  const data = sheet.getDataRange().getValues();
  const header = data[0];

  const colIndex = header.indexOf(columnName);
  if (colIndex === -1) return;

  // M√°r l√©tezik?
  for (let i = 1; i < data.length; i++) {
    if (
      String(data[i][colIndex]).trim().toLowerCase() ===
      String(value).trim().toLowerCase()
    ) {
      return;
    }
  }

  // K√∂vetkez≈ë √ºres sor keres√©se ebben az oszlopban
  let insertRow = 1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][colIndex] === "" || data[i][colIndex] === null) {
      insertRow = i + 1; // Google Sheets 1-indexelt
      break;
    }
    insertRow = i + 2; // ha nincs t√∂bb √ºres cella
  }

  // Besz√∫rjuk az √©rt√©ket az adott oszlop megfelel≈ë cell√°j√°ba
  sheet.getRange(insertRow, colIndex + 1).setValue(value);
}
/**
 * √öj √©rt√©k hozz√°ad√°sa a Value_Sets lap megfelel≈ë oszlop√°hoz.
 */
function addValueToSet_(p) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Value_Sets");
  const setName = p.set;
  const value = (p.value || "").trim();

  if (!setName || !value) {
    return { success: false, message: "Hi√°nyz√≥ set vagy √©rt√©k." };
  }

  const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const col = header.indexOf(setName);

  if (col === -1) {
    return { success: false, message: "Nincs ilyen oszlop: " + setName };
  }

  const lastRow = sheet.getLastRow();
  let existingValues = [];

  // Ha van legal√°bb egy adat sor a fejl√©c alatt, akkor olvassuk be a megl√©v≈ë √©rt√©keket
  if (lastRow > 1) {
    existingValues = sheet
      .getRange(2, col + 1, lastRow - 1, 1)
      .getValues()
      .map(r => (r[0] || "").toString().trim().toLowerCase())
      .filter(v => v !== "");
  }

  // m√°r l√©tezik?
  if (existingValues.includes(value.toLowerCase())) {
    return { success: true, message: "√ârt√©k m√°r l√©tezik." };
  }

  // √∫j √©rt√©k besz√∫r√°sa az oszlop v√©g√©re
  sheet.getRange(lastRow + 1, col + 1).setValue(value);

  return { success: true, message: "√ârt√©k hozz√°adva." };
}
/**
 * Shared_Expenses lap tartalm√°nak lek√©r√©se
 */
function getSharedExpenses_(p) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Shared_Expenses");
  if (!sheet) {
    return { success: false, error: 'Nem tal√°lhat√≥ a "Shared_Expenses" munkalap.' };
  }

  const data = sheet.getDataRange().getValues();
  if (data.length < 2) {
    return { success: true, data: [] };
  }

  const header = data[0];
  const rows = data.slice(1).map(row => {
    const obj = {};
    header.forEach((name, idx) => {
      obj[name] = row[idx];
    });
    return obj;
  });

  return { success: true, data: rows };
}
/**
 * Megosztott tranzakci√≥ szinkroniz√°l√°sa a Shared_Expenses lapra.
 */
function syncSharedExpenseForTransaction_(tx) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Shared_Expenses");
  if (!sheet) {
    // Ha nincs ilyen lap, nem dobunk hib√°t, csak kil√©p√ºnk
    return;
  }

  const data = sheet.getDataRange().getValues();
  const header = data[0];

  // Oszlopindexek
  const colId            = header.indexOf("id");
  const colCreatedAt     = header.indexOf("created_at");
  const colTxId          = header.indexOf("transaction_id");
  const colMonth         = header.indexOf("month");
  const colDate          = header.indexOf("date");
  const colTitle         = header.indexOf("title");
  const colAmount        = header.indexOf("amount");
  const colPaidBy        = header.indexOf("paid_by");
  const colOwnAmount     = header.indexOf("own_amount");
  const colRemaining     = header.indexOf("remaining_amount");
  const colPartnerShare  = header.indexOf("partner_share");
  const colBalanceImpact = header.indexOf("balance_impact");
  const colNotes         = header.indexOf("notes");

  // Megl√©v≈ë sor keres√©se transaction_id alapj√°n
  let rowIndex = -1;
  let existingRow = null;

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][colTxId]).trim() === String(tx.id).trim()) {
      rowIndex = i + 1;  // Sheets 1-indexelt
      existingRow = data[i];
      break;
    }
  }

  // Ha a tranzakci√≥ NEM megosztott ‚Üí t√∂r√∂lj√ºk a Shared_Expenses sor√°t (ha volt)
  const isShared = String(tx.is_shared || "").trim() !== "" &&
                   String(tx.is_shared).toLowerCase() !== "false";

  if (!isShared) {
    if (rowIndex !== -1) {
      sheet.deleteRow(rowIndex);
    }
    return;
  }

  // Ha megosztott ‚Üí √∫j sor vagy friss√≠t√©s
  if (rowIndex === -1) {
    // √öj sor besz√∫r√°sa
    const newRow = new Array(header.length).fill("");

    newRow[colId]            = Utilities.getUuid();
    newRow[colCreatedAt]     = new Date();
    newRow[colTxId]          = tx.id;
    newRow[colMonth]         = tx.month;
    newRow[colDate]          = formatDateForStore_(tx.date);
    newRow[colTitle]         = tx.title;
    newRow[colAmount]        = tx.amount;
    newRow[colPaidBy]        = tx.paid_by || "";

    // tov√°bbi mez≈ëk k√©s≈ëbb sz√°m√≠that√≥k
    sheet.appendRow(newRow);

  } else {
    // Megl√©v≈ë sor friss√≠t√©se
    const row = existingRow.slice();

    row[colMonth]     = tx.month;
    row[colDate]      = formatDateForStore_(tx.date);
    row[colTitle]     = tx.title;
    row[colAmount]    = tx.amount;
    row[colPaidBy]    = tx.paid_by || row[colPaidBy];

    sheet.getRange(rowIndex, 1, 1, header.length).setValues([row]);
  }
}
/**
 * Shared_Expenses egy mez≈ëj√©nek manu√°lis m√≥dos√≠t√°sa
 */
function updateSharedExpense_(id, field, value) {
  const sheet = SpreadsheetApp.getActive().getSheetByName("Shared_Expenses");
  if (!sheet) {
    return { success: false, error: 'Nem tal√°lhat√≥ a "Shared_Expenses" munkalap.' };
  }

  const data = sheet.getDataRange().getValues();
  const header = data[0];

  // Oszlopindexek
  const colId        = header.indexOf("id");
  const colPaidBy    = header.indexOf("paid_by");
  const colOwnAmount = header.indexOf("own_amount");

  // Ellen≈ërz√©s
  if (colId === -1) {
    return { success: false, error: "Nincs ID oszlop a Shared_Expenses lapban." };
  }

  // A mez≈ëk k√∂z√ºl csak ezt a kett≈ët engedj√ºk m√≥dos√≠tani
  let targetCol = null;
  if (field === "paid_by") targetCol = colPaidBy;
  if (field === "own_amount") targetCol = colOwnAmount;

  if (targetCol === null) {
    return { success: false, error: "Nem m√≥dos√≠that√≥ mez≈ë: " + field };
  }

  // Sor keres√©se az ID alapj√°n
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][colId]).trim() === String(id).trim()) {
      rowIndex = i + 1; // 1-indexelt
      break;
    }
  }

  if (rowIndex === -1) {
    return { success: false, error: "Nincs ilyen Shared Expense ID: " + id };
  }

  // M√≥dos√≠t√°s
  sheet.getRange(rowIndex, targetCol + 1).setValue(value);

  return { success: true, id: id, field: field, value: value };
}

/**
 * D√°tum egys√©ges t√°rol√°si form√°tumra alak√≠t√°sa: YYYY.MM.DD
 */
function formatDateForStore_(value) {
  if (!value) return "";
  const d = new Date(value);
  if (isNaN(d.getTime())) return value;
  return (
    d.getFullYear() +
    "." +
    String(d.getMonth() + 1).padStart(2, "0") +
    "." +
    String(d.getDate()).padStart(2, "0")
  );
}
